## 约瑟夫环

**方法一：队列模拟**

**方法二：递归公式解决**

我们回顾上面的优化过程，上面用求余可以解决m比n大很多很多的情况(即理论上需要转很多很多圈的情况)。但是还可能存在n本身就很大的情况，无论是顺序表ArrayList还是链表LinkedList去频繁查询、删除都是很低效的。

所以聪明的人就开始从数据找一些规律或者关系。先抛出==公式==

```
f(n,m)=(f(n-1,m)+m)%n
f(n,m)指n个人，报第m个编号出列最终编号
```

下面要认真看一下我的分析过程：

我们举个例子，有`0 1 2 3 4 5 6 7 8 9`十个数字，假设m为3,最后结果可以先记成`f(10,3)`，即使我们不知道它是多少。

当进行第一次时候，找到元素2 删除，此时还剩9个元素，但**起始位置已经变成元素3**。等价成`3 4 5 6 7 8 9 0 1`这9个数字重写开始找。

<img src="Leetcode.assets/image-20220505113050568.png" alt="image-20220505113050568" style="zoom: 80%;" />

此时这个序列最终剩下的一个值即为`f(10,3)`，这个序列的值和`f(9,3)`不同，**但是都是9个数且m等于3，所以其删除位置是相同的，即算法大体流程是一致的，只是各位置上的数字不一样。**所以我们需要做的事情是**找找这个序列上和`f(9,3)`值上有没有什么联系**。

寻找过程中别忘记两点，首先可通过**%符号**对数字有效扩充，即我们可以将`3 4 5 6 7 8 9 0 1`这个序列看成`(3,4,5,6,7,8,9,10,11)%10`.这里的10即为此时的n数值。

另外数值如果是连续的，那么最终一个结果的话是可以找到联系的(差值为一个定制)。所以我们可以就找到`f(10,3)`和`f(9,3)`值之间结果的关系，可以看下图：

<img src="Leetcode.assets/image-20220505113110983.png" alt="image-20220505113110983" style="zoom:80%;" />

所以f(10,3)的结果就可以转化为f(9,3)的表达,后面也是同理：

```
f(10,3)=(f(9,3)+3)%10
f(9,3)=(f(8,3)+3)%9
……
f(2,3)=(f(1,3)+3)%2
f(1,3)=0
```

